/**
 * CHECK: Type Safety
 * Flags unsafe type patterns that bypass the type system or suppress linting.
 */

import fs from "node:fs";
import path from "node:path";
import { c, ROOT, relPath, walkDir } from "./utils.js";

export function run() {
  const DIRS = [path.join(ROOT, "src"), path.join(ROOT, "convex"), path.join(ROOT, "scripts")];
  const IGNORE_PATTERNS = [
    /routeTree\.gen\.ts$/, // Auto-generated by TanStack Router
    /\.stories\.tsx?$/, // Storybook files
    /\.test\.tsx?$/, // Test files
    /\.spec\.tsx?$/, // Test files
    /check-type-safety\.js$/, // This file (contains pattern strings)
    /useIssueModal\.ts$/, // TanStack Router generic hook requires type casting
    /convex\/lib\//, // Convex internal utilities with complex generics
    /convex\/softDeleteCleanup\.ts$/, // Convex internal cleanup utility
    /convex\/issues\/queries\.ts$/, // Convex search index type mismatch requires casting
    /src\/components\/KeyboardShortcutsHelp\.tsx$/, // Contains explicit suppressions
  ];

  let errorCount = 0;
  const errors = [];

  const PATTERNS = [
    { regex: /\)\s*as\s+any\b/, message: "Unsafe 'as any' type assertion" },
    { regex: /\)\s*as\s+unknown\s+as\b/, message: "Unsafe 'as unknown as' double assertion" },
    { regex: /\)\s*as\s+never\b/, message: "Unsafe 'as never' type assertion" },
    { regex: /@ts-ignore\b/, message: "@ts-ignore suppresses type errors" },
    { regex: /@ts-nocheck\b/, message: "@ts-nocheck disables type checking" },
    { regex: /@ts-expect-error\b/, message: "@ts-expect-error suppresses type errors" },
    { regex: /biome-ignore\b/, message: "biome-ignore suppresses lint rules" },
  ];

  function checkFile(filePath) {
    const rel = relPath(filePath);
    if (IGNORE_PATTERNS.some((p) => p.test(rel))) return;

    const content = fs.readFileSync(filePath, "utf-8");
    const lines = content.split("\n");

    lines.forEach((line, index) => {
      for (const { regex, message } of PATTERNS) {
        if (regex.test(line)) {
          errors.push(`  ${c.red}ERROR${c.reset} ${rel}:${index + 1} - ${message}`);
          errorCount++;
        }
      }
    });
  }

  for (const dir of DIRS) {
    if (!fs.existsSync(dir)) continue;
    const files = walkDir(dir, { extensions: new Set([".ts", ".tsx", ".js", ".mjs"]) });
    for (const f of files) checkFile(f);
  }

  return {
    passed: errorCount === 0,
    errors: errorCount,
    detail: errorCount > 0 ? `${errorCount} error(s)` : null,
    messages: errors,
  };
}
