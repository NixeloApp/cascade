/**
 * CHECK: Type Safety
 * Flags unsafe type patterns that bypass the type system or suppress linting.
 */

import fs from "node:fs";
import path from "node:path";
import { c, ROOT, relPath, walkDir } from "./utils.js";

export function run() {
  const DIRS = [path.join(ROOT, "src"), path.join(ROOT, "convex"), path.join(ROOT, "scripts")];
  const IGNORE_PATTERNS = [
    /routeTree\.gen\.ts$/, // Auto-generated by TanStack Router
    /\.stories\.tsx?$/, // Storybook files
    /\.test\.tsx?$/, // Test files
    /\.spec\.tsx?$/, // Test files
    /check-type-safety\.js$/, // This file (contains pattern strings)
    /useIssueModal\.ts$/, // TanStack Router generic hook requires type casting
    /convex\/lib\//, // Convex internal utilities with complex generics
    /convex\/softDeleteCleanup\.ts$/, // Convex internal cleanup utility
  ];

  let errorCount = 0;
  let warningCount = 0;
  const errors = [];

  const PATTERNS = [
    { regex: /\)\s*as\s+any\b/, message: "Unsafe 'as any' type assertion", level: "error" },
    {
      regex: /\)\s*as\s+unknown\s+as\b/,
      message: "Unsafe 'as unknown as' double assertion",
      level: "error",
    },
    { regex: /\)\s*as\s+never\b/, message: "Unsafe 'as never' type assertion", level: "error" },
    { regex: /@ts-ignore\b/, message: "@ts-ignore suppresses type errors", level: "error" },
    { regex: /@ts-nocheck\b/, message: "@ts-nocheck disables type checking", level: "error" },
    {
      regex: /@ts-expect-error\b/,
      message: "@ts-expect-error suppresses type errors",
      level: "warning",
    },
    {
      regex: /biome-ignore\b/,
      message: "biome-ignore suppresses lint rules",
      level: "warning",
    },
  ];

  function checkFile(filePath) {
    const rel = relPath(filePath);
    if (IGNORE_PATTERNS.some((p) => p.test(rel))) return;

    const content = fs.readFileSync(filePath, "utf-8");
    const lines = content.split("\n");

    lines.forEach((line, index) => {
      for (const { regex, message, level } of PATTERNS) {
        if (regex.test(line)) {
          const color = level === "error" ? c.red : c.yellow;
          errors.push(`  ${color}${level.toUpperCase()}${c.reset} ${rel}:${index + 1} - ${message}`);
          if (level === "error") {
            errorCount++;
          } else {
            warningCount++;
          }
        }
      }
    });
  }

  for (const dir of DIRS) {
    if (!fs.existsSync(dir)) continue;
    const files = walkDir(dir, { extensions: new Set([".ts", ".tsx", ".js", ".mjs"]) });
    for (const f of files) checkFile(f);
  }

  let detail = null;
  if (errorCount > 0) {
    detail = `${errorCount} error(s)${warningCount > 0 ? `, ${warningCount} warning(s)` : ""}`;
  } else if (warningCount > 0) {
    detail = `${warningCount} warning(s)`;
  }

  return {
    passed: errorCount === 0,
    errors: errorCount,
    warnings: warningCount,
    detail,
    messages: errors,
  };
}
